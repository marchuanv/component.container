import { MethodMember, Schema } from "../registry.mjs";
export class ClassIntegrity {
    /**
     * @param { MethodMember } ctorMethodMember
    */
    constructor(ctorMethodMember) {
        const targetClass = new.target;
        if (targetClass === ClassIntegrity.prototype || targetClass === ClassIntegrity) {
            throw new Error(`${ClassIntegrity.name} class is abstract`);
        }
        const existingSchema = Schema.getSchema(ctorMethodMember.typeDefinition);
        if (!existingSchema) {
            const properties = {};
            for (const param of ctorMethodMember.parameters) {
                properties[param.name] = {};
                const property = properties[param.name];
                let typeDefinition = param.typeDefinition;
                let paramSchema = Schema.getSchema(typeDefinition);
                if (!paramSchema) {
                    throw new Error(`schema for ${JSON.stringify({
                        name: typeDefinition.name,
                        typeName: typeDefinition.typeName,
                        Id: typeDefinition.Id
                    })} does not exist`);
                }
                property['$ref'] = paramSchema.url;
            }
            Schema.createSchema(ctorMethodMember.typeDefinition, properties);
        }
    }
    async validate() {
        const existingSchema = Schema.getSchema(this.ctor.typeDefinition);
        const parameters = this.ctor.parameters;
        const obj = parameters.reduce((_obj, param) => {
            _obj[param.name] = param.value;
            return _obj;
        }, {});
        await existingSchema.validate(obj);
    }
}